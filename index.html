<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Seismic Simulator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
      max-width: 300px;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: black;
    }
    #toolLabel { font-weight: bold; }
    #startSim, #reload, #replay { display: none; margin-top: 10px; }
    .legend {
      margin-top: 10px;
      font-size: 12px;
      line-height: 1.4em;
    }
    .legend div::before {
      content: '⬤ ';
      font-size: 14px;
      display: inline-block;
      width: 1.2em;
    }
    .red::before { color: red; }
    .green::before { color: green; }
    .cyan::before { color: cyan; }
    .magenta::before { color: magenta; }
    .gray::before { color: gray; }
    .blue::before { color: blue; }
    .lime::before { color: lime; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="tool">Toggle Tool</button>
    <span>Current Tool: <span id="toolLabel">Pen</span></span><br>
    <label>Magnitude: <input id="mag" type="number" min="5.0" max="6.6" step="0.1" value="5.0"></label><br>
    <p>Click to place epicenter, then press Start</p>
    <button id="startSim">Start Simulation</button>
    <button id="replay">Replay Simulation</button>
    <button id="reload">Reload Simulation</button>

    <div class="legend">
      <strong>Legend</strong>
      <div class="red">P-wave (+)</div>
      <div class="cyan">P-wave (−)</div>
      <div class="green">S-wave (+)</div>
      <div class="magenta">S-wave (−)</div>
      <div class="gray">Neutral zone</div>
      <div class="blue">Reflective border</div>
      <div class="lime">Epicenter</div>
    </div>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const cols = 100, rows = 100;
    const kmPerCell = 0.5;
    const dt = 0.01;
    const pWaveConstantVelocity = 6.0, sWaveConstantVelocity = 3.5;

    var cellWidth, cellHeight;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    cellWidth = canvas.width / cols;
    cellHeight = canvas.height / rows;

    var simRunning = false;
    var drawTool = 'pen';
    var isDrawing = false;
    var originX = null, originY = null;
    var storedMag = 5.0;

    const pWaveDisplacement = [], sWaveDisplacement = [], pWaveVelocity = [], sWaveVelocity = [], borders = [];
    for (var y = 0; y < rows; y++) {
      pWaveDisplacement[y] = new Float32Array(cols);
      sWaveDisplacement[y] = new Float32Array(cols);
      pWaveConstantVelocity[y] = new Float32Array(cols);
      sWaveVelocity[y] = new Float32Array(cols);
      borders[y] = new Uint8Array(cols);
    }

    function resetFields() {
      for (var y = 0; y < rows; y++) {
        pWaveDisplacement[y].fill(0);
        sWaveDisplacement[y].fill(0);
        pWaveVelocity[y].fill(0);
        sWaveVelocity[y].fill(0);
      }
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cellWidth = canvas.width / cols;
      cellHeight = canvas.height / rows;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    function drawGrid() {
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      for (var x = 0; x <= cols; x++) {
        ctx.beginPath(); ctx.moveTo(x * cellWidth, 0); ctx.lineTo(x * cellWidth, canvas.height); ctx.stroke();
      }
      for (var y = 0; y <= rows; y++) {
        ctx.beginPath(); ctx.moveTo(0, y * cellHeight); ctx.lineTo(canvas.width, y * cellHeight); ctx.stroke();
      }
    }

    function drawWaves() {
      for (var y = 0; y < rows; y++) {
        for (var x = 0; x < cols; x++) {
          if (borders[y][x]) continue;

          const p = pWaveDisplacement[y][x];
          const s = sWaveDisplacement[y][x];

          const r = Math.max(0, Math.min(255, 128 + 127 * (p - s)));
          const g = Math.max(0, Math.min(255, 128 + 127 * (s - p)));
          const b = Math.max(0, Math.min(255, 128 - 127 * (p + s)));

          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
        }
      }

      if (originX !== null && originY !== null) {
        ctx.fillStyle = 'lime';
        ctx.fillRect(originX * cellWidth, originY * cellHeight, cellWidth, cellHeight);
      }
    }

    function drawBorders() {
      ctx.fillStyle = "#00f";
      for (var y = 0; y < rows; y++) {
        for (var x = 0; x < cols; x++) {
          if (borders[y][x]) ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
        }
      }
    }

    function update() {
      if (!simRunning) return;
      const scaleVp = (pWaveConstantVelocity * dt / kmPerCell) ** 2;
      const scaleVs = (sWaveConstantVelocity * dt / kmPerCell) ** 2;

      for (var y = 1; y < rows - 1; y++) {
        for (var x = 1; x < cols - 1; x++) {
          if (borders[y][x]) continue;
          const lapV = pWaveDisplacement[y][x+1] + pWaveDisplacement[y][x-1] + pWaveDisplacement[y+1][x] + pWaveDisplacement[y-1][x] - 4 * pWaveDisplacement[y][x];
          const lapH = sWaveDisplacement[y][x+1] + sWaveDisplacement[y][x-1] + sWaveDisplacement[y+1][x] + sWaveDisplacement[y-1][x] - 4 * sWaveDisplacement[y][x];
          pWaveVelocity[y][x] += scaleVp * lapV;
          sWaveVelocity[y][x] += scaleVs * lapH;
          pWaveVelocity[y][x] *= 0.99;
          sWaveVelocity[y][x] *= 0.99;
        }
      }
      for (var y = 0; y < rows; y++) {
        for (var x = 0; x < cols; x++) {
          if (borders[y][x]) {
            pWaveVelocity[y][x] *= -0.5;
            sWaveVelocity[y][x] *= -0.5;
          }
          pWaveDisplacement[y][x] += pWaveVelocity[y][x];
          sWaveDisplacement[y][x] += sWaveVelocity[y][x];
        }
      }
    }

    function animate() {
      update();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawWaves();
      drawBorders();
      requestAnimationFrame(animate);
    }
    animate();

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellWidth);
      const y = Math.floor((e.clientY - rect.top) / cellHeight);
      if (simRunning) return;
      if (drawTool === 'pen' || drawTool === 'eraser') {
        paint(x, y); isDrawing = true;
      } else if (drawTool === 'origin') {
        if (borders[y][x] === 1) return;
        originX = x; originY = y;
        document.getElementById("startSim").style.display = 'inline-block';
      }
    });

    canvas.addEventListener("mousemove", e => {
      if (!isDrawing || simRunning) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellWidth);
      const y = Math.floor((e.clientY - rect.top) / cellHeight);
      paint(x, y);
    });

    window.addEventListener("mouseup", () => { isDrawing = false; });

    function paint(x, y) {
      if (x >= 0 && x < cols && y >= 0 && y < rows) {
        if (drawTool === 'pen') {
          if (x === originX && y === originY) return;
          borders[y][x] = 1;
        }
        else if (drawTool === 'eraser') {
          borders[y][x] = 0;
          if (x === originX && y === originY) {
            originX = null;
            originY = null;
            document.getElementById("startSim").style.display = 'none';
          }
        }
      }
    }

    document.getElementById("tool").onclick = () => {
      if (simRunning) return;
      if (drawTool === 'pen') drawTool = 'eraser';
      else if (drawTool === 'eraser') drawTool = 'origin';
      else drawTool = 'pen';
      document.getElementById("toolLabel").innerText = drawTool.charAt(0).toUpperCase() + drawTool.slice(1);
    };

    function injectEarthquake(mag) {
      const r = 3;
      for (var dy = -r; dy <= r; dy++) {
        for (var dx = -r; dx <= r; dx++) {
          const ix = originX + dx;
          const iy = originY + dy;
          if (ix >= 0 && ix < cols && iy >= 0 && iy < rows) {
            const d = Math.hypot(dx, dy);
            const amp = mag * Math.exp(-d);
            pWaveDisplacement[iy][ix] += amp;
            sWaveDisplacement[iy][ix] += amp * 0.8;
          }
        }
      }
    }

    document.getElementById("startSim").onclick = () => {
      if (originX !== null && originY !== null && !simRunning) {
        storedMag = parseFloat(document.getElementById("mag").value);
        resetFields();
        injectEarthquake(storedMag);
        simRunning = true;
        document.getElementById("startSim").style.display = 'none';
        document.getElementById("reload").style.display = 'inline-block';
        document.getElementById("replay").style.display = 'inline-block';
      }
    };

    document.getElementById("replay").onclick = () => {
      if (originX !== null && originY !== null) {
        resetFields();
        injectEarthquake(storedMag);
        simRunning = true;
      }
    };

    document.getElementById("reload").onclick = () => location.reload();
  </script>
</body>
</html>